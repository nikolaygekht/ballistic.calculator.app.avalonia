using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Gehtsoft.Measurements;
using BallisticCalculator.Controls.Controllers;
using BallisticCalculator.Controls.Models;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;

namespace BallisticCalculator.Controls.Controls;

public partial class MeasurementControl : UserControl
{
    private object? _controller; // Will be MeasurementController<T>
    private Type? _unitType; // The unit enum type (DistanceUnit, VelocityUnit, etc.)

    #region Styled Properties

    public static readonly StyledProperty<Type?> UnitTypeProperty =
        AvaloniaProperty.Register<MeasurementControl, Type?>(
            nameof(UnitType),
            coerce: (obj, value) =>
            {
                if (obj is MeasurementControl control && value != null)
                {
                    control._unitType = (Type)value;
                    control.InitializeController();
                }
                return value;
            });

    public static readonly StyledProperty<object?> ValueProperty =
        AvaloniaProperty.Register<MeasurementControl, object?>(
            nameof(Value),
            defaultBindingMode: Avalonia.Data.BindingMode.TwoWay);

    public static readonly StyledProperty<double> IncrementProperty =
        AvaloniaProperty.Register<MeasurementControl, double>(
            nameof(Increment), 1.0);

    public static readonly StyledProperty<double> MinimumProperty =
        AvaloniaProperty.Register<MeasurementControl, double>(
            nameof(Minimum), -10000.0);

    public static readonly StyledProperty<double> MaximumProperty =
        AvaloniaProperty.Register<MeasurementControl, double>(
            nameof(Maximum), 10000.0);

    public static readonly StyledProperty<int?> DecimalPointsProperty =
        AvaloniaProperty.Register<MeasurementControl, int?>(
            nameof(DecimalPoints), null);

    public static readonly StyledProperty<double> UnitPartWidthProperty =
        AvaloniaProperty.Register<MeasurementControl, double>(
            nameof(UnitPartWidth), 80.0);

    public static readonly StyledProperty<CultureInfo> CultureProperty =
        AvaloniaProperty.Register<MeasurementControl, CultureInfo>(
            nameof(Culture), CultureInfo.InvariantCulture);

    #endregion

    #region Properties

    /// <summary>
    /// The unit enum type (DistanceUnit, VelocityUnit, WeightUnit, etc.)
    /// </summary>
    public Type? UnitType
    {
        get => GetValue(UnitTypeProperty);
        set => SetValue(UnitTypeProperty, value);
    }

    /// <summary>
    /// The measurement value (Measurement&lt;T&gt; where T is UnitType)
    /// </summary>
    public object? Value
    {
        get => GetValueInternal(); // Always compute from UI, like WinForms
        set => SetValue(ValueProperty, value);
    }

    public double Increment
    {
        get => GetValue(IncrementProperty);
        set => SetValue(IncrementProperty, value);
    }

    public double Minimum
    {
        get => GetValue(MinimumProperty);
        set => SetValue(MinimumProperty, value);
    }

    public double Maximum
    {
        get => GetValue(MaximumProperty);
        set => SetValue(MaximumProperty, value);
    }

    public int? DecimalPoints
    {
        get => GetValue(DecimalPointsProperty);
        set => SetValue(DecimalPointsProperty, value);
    }

    public double UnitPartWidth
    {
        get => GetValue(UnitPartWidthProperty);
        set => SetValue(UnitPartWidthProperty, value);
    }

    public CultureInfo Culture
    {
        get => GetValue(CultureProperty);
        set => SetValue(CultureProperty, value);
    }

    public bool IsEmpty => string.IsNullOrWhiteSpace(NumericPart?.Text);

    #endregion

    #region Events

    public event EventHandler? Changed;

    #endregion

    #region Constructor & Initialization

    public MeasurementControl()
    {
        InitializeComponent();

        // Set initial UnitPart width
        if (UnitPart != null)
            UnitPart.Width = UnitPartWidth;

        // Initialize units if UnitType already set (from property coerce)
        if (_unitType != null)
        {
            UpdateUnits();
        }

        // Wire up events
        WireEvents();
    }

    private void WireEvents()
    {
        // Focus management
        this.GotFocus += OnControlGotFocus;

        // Keyboard handling
        if (NumericPart != null)
        {
            NumericPart.KeyDown += NumericPart_KeyDown;
            NumericPart.AddHandler(TextInputEvent, NumericPart_TextInput, RoutingStrategies.Tunnel);
            NumericPart.TextChanged += NumericPart_TextChanged;
        }

        // ComboBox changes
        if (UnitPart != null)
        {
            UnitPart.SelectionChanged += UnitPart_SelectionChanged;
        }

        // Property changed
        this.PropertyChanged += OnPropertyChanged;
    }

    private void InitializeController()
    {
        if (_unitType == null) return;

        // Create MeasurementController<T> using reflection
        var controllerType = typeof(MeasurementController<>).MakeGenericType(_unitType);
        _controller = Activator.CreateInstance(controllerType);

        // Sync properties to controller
        SyncPropertiesToController();

        // Update units
        UpdateUnits();
    }

    private void UpdateUnits()
    {
        if (UnitPart == null || _unitType == null) return;

        UnitPart.Items.Clear();

        // Create Measurement<T> type
        var measurementType = typeof(Measurement<>).MakeGenericType(_unitType);

        // Call Measurement<T>.GetUnitNames() static method (like WinForms version)
        var getUnitNamesMethod = measurementType.GetMethod("GetUnitNames", BindingFlags.Public | BindingFlags.Static);
        if (getUnitNamesMethod == null) return;

        // Returns Tuple<T, string>[]
        var tuples = getUnitNamesMethod.Invoke(null, Array.Empty<object>()) as System.Collections.IEnumerable;
        if (tuples == null) return;

        // Get Tuple<T, string> type for property access
        var tupleType = typeof(Tuple<,>).MakeGenericType(_unitType, typeof(string));
        var unitProperty = tupleType.GetProperty("Item1");
        var nameProperty = tupleType.GetProperty("Item2");

        foreach (var tuple in tuples)
        {
            var unitValue = unitProperty?.GetValue(tuple);
            var unitName = nameProperty?.GetValue(tuple) as string;

            if (unitValue != null && unitName != null)
            {
                UnitPart.Items.Add(new UnitItem(unitValue, unitName));
            }
        }

        // Select first item as default
        if (UnitPart.Items.Count > 0)
            UnitPart.SelectedIndex = 0;
    }

    private void SyncPropertiesToController()
    {
        if (_controller == null) return;

        var controllerType = _controller.GetType();
        controllerType.GetProperty("Increment")?.SetValue(_controller, Increment);
        controllerType.GetProperty("Minimum")?.SetValue(_controller, Minimum);
        controllerType.GetProperty("Maximum")?.SetValue(_controller, Maximum);
        controllerType.GetProperty("DecimalPoints")?.SetValue(_controller, DecimalPoints);
    }

    #endregion

    #region Value Property Logic

    private object? GetValueInternal()
    {
        // Parse from current text
        if (UnitPart?.SelectedItem == null || _controller == null)
            return null;

        var unit = GetSelectedUnit();
        if (unit == null) return null;

        // Call Value method on controller
        var valueMethod = _controller.GetType().GetMethod("Value");
        var result = valueMethod?.Invoke(_controller, new object?[] { NumericPart?.Text ?? "", unit, DecimalPoints, Culture });

        return result;
    }

    private void SetValueInternal(object? value)
    {
        if (NumericPart == null || UnitPart == null)
            return;

        if (value == null)
        {
            NumericPart.Text = "";
            ClearValidationError();
            return;
        }

        if (_controller == null)
            return;

        // Ensure units are populated (defensive - handles timing issues)
        if (UnitPart.Items.Count == 0)
        {
            UpdateUnits();
        }

        // Call ParseValue method on controller
        var parseValueMethod = _controller.GetType().GetMethod("ParseValue");
        var parameters = new object?[] { value, null, null, DecimalPoints, Culture };
        parseValueMethod?.Invoke(_controller, parameters);

        string text = (string)(parameters[1] ?? "");
        object? unit = parameters[2];

        // Update UI
        NumericPart.Text = text;
        SelectUnit(unit);

        // Validate
        ValidateValue();
    }

    private object? GetSelectedUnit()
    {
        if (UnitPart?.SelectedItem is UnitItem unitItem)
            return unitItem.Unit;
        return null;
    }

    private void SelectUnit(object? unit)
    {
        if (UnitPart == null || unit == null) return;

        foreach (var item in UnitPart.Items)
        {
            if (item is UnitItem unitItem && UnitsEqual(unitItem.Unit, unit))
            {
                UnitPart.SelectedItem = item;
                return;
            }
        }
    }

    private bool UnitsEqual(object? unit1, object? unit2)
    {
        if (unit1 == null || unit2 == null) return false;
        return unit1.Equals(unit2);
    }

    private void OnPropertyChanged(object? sender, AvaloniaPropertyChangedEventArgs e)
    {
        if (e.Property == ValueProperty)
        {
            SetValueInternal(e.NewValue);
        }
        else if (e.Property == IncrementProperty)
        {
            _controller?.GetType().GetProperty("Increment")?.SetValue(_controller, (double)e.NewValue!);
        }
        else if (e.Property == MinimumProperty)
        {
            _controller?.GetType().GetProperty("Minimum")?.SetValue(_controller, (double)e.NewValue!);
            ValidateValue();
        }
        else if (e.Property == MaximumProperty)
        {
            _controller?.GetType().GetProperty("Maximum")?.SetValue(_controller, (double)e.NewValue!);
            ValidateValue();
        }
        else if (e.Property == DecimalPointsProperty)
        {
            _controller?.GetType().GetProperty("DecimalPoints")?.SetValue(_controller, (int?)e.NewValue);
        }
        else if (e.Property == UnitPartWidthProperty)
        {
            if (UnitPart != null)
                UnitPart.Width = (double)e.NewValue!;
        }
    }

    #endregion

    #region Focus Management

    private void OnControlGotFocus(object? sender, GotFocusEventArgs e)
    {
        // When control receives focus, focus NumericPart first
        NumericPart?.Focus();
    }

    #endregion

    #region Keyboard Input Handling

    private void NumericPart_TextInput(object? sender, TextInputEventArgs e)
    {
        if (string.IsNullOrEmpty(e.Text) || NumericPart == null || _controller == null)
            return;

        foreach (char c in e.Text)
        {
            if (c == '\b') // Backspace
                continue;

            // Call AllowKeyInEditor on controller
            var allowKeyMethod = _controller.GetType().GetMethod("AllowKeyInEditor");
            var allowed = (bool)(allowKeyMethod?.Invoke(_controller, new object?[]
            {
                NumericPart.Text ?? "",
                NumericPart.CaretIndex,
                NumericPart.SelectionEnd - NumericPart.SelectionStart,
                c,
                Culture
            }) ?? false);

            if (!allowed)
            {
                e.Handled = true;
                return;
            }
        }
    }

    private void NumericPart_KeyDown(object? sender, KeyEventArgs e)
    {
        if (NumericPart == null || UnitPart == null)
            return;

        if (e.Key == Key.Up && e.KeyModifiers == KeyModifiers.None)
        {
            DoIncrement(true);
            e.Handled = true;
        }
        else if (e.Key == Key.Down && e.KeyModifiers == KeyModifiers.None)
        {
            DoIncrement(false);
            e.Handled = true;
        }
        else if (e.Key == Key.Tab && e.KeyModifiers == KeyModifiers.None)
        {
            // Tab from NumericPart moves to UnitPart
            UnitPart.Focus();
            e.Handled = true;
        }
    }

    private void DoIncrement(bool increment)
    {
        if (NumericPart == null || _controller == null)
            return;

        // Call IncrementValue on controller
        var incrementMethod = _controller.GetType().GetMethod("IncrementValue");
        var result = incrementMethod?.Invoke(_controller, new object?[]
        {
            NumericPart.Text ?? "",
            increment,
            Culture
        }) as string;

        if (result != null)
        {
            NumericPart.Text = result;
            RaiseChanged();
        }
    }

    #endregion

    #region Validation

    private void ValidateValue()
    {
        if (NumericPart == null)
            return;

        var value = GetValueInternal();

        if (string.IsNullOrWhiteSpace(NumericPart.Text))
        {
            ClearValidationError();
            return;
        }

        if (value == null)
        {
            ShowValidationError("Value must be a valid number");
            return;
        }

        // Get the numeric value from the Measurement<T>
        var valueType = value.GetType();
        var valueProperty = valueType.GetProperty("Value");
        if (valueProperty != null)
        {
            var numericValue = (double)valueProperty.GetValue(value)!;

            if (numericValue < Minimum)
            {
                ShowValidationError($"Value must be at least {Minimum}");
                return;
            }

            if (numericValue > Maximum)
            {
                ShowValidationError($"Value must not exceed {Maximum}");
                return;
            }
        }

        ClearValidationError();
    }

    private void ShowValidationError(string message)
    {
        if (ValidationErrorText == null)
            return;

        ValidationErrorText.Text = message;
        ValidationErrorText.IsVisible = true;

        // Also add visual indicator to TextBox
        if (NumericPart != null)
        {
            NumericPart.BorderBrush = Avalonia.Media.Brushes.Red;
            NumericPart.BorderThickness = new Thickness(2);
        }
    }

    private void ClearValidationError()
    {
        if (ValidationErrorText != null)
        {
            ValidationErrorText.IsVisible = false;
        }

        // Reset TextBox border
        if (NumericPart != null)
        {
            NumericPart.ClearValue(TextBox.BorderBrushProperty);
            NumericPart.ClearValue(TextBox.BorderThicknessProperty);
        }
    }

    #endregion

    #region Change Events

    private void NumericPart_TextChanged(object? sender, TextChangedEventArgs e)
    {
        ValidateValue();
        RaiseChanged();
    }

    private void UnitPart_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        RaiseChanged();
    }

    private void RaiseChanged()
    {
        // Just raise the Changed event
        // Value property getter will compute value on-demand from UI
        Changed?.Invoke(this, EventArgs.Empty);
    }

    #endregion

    #region Public Helper Methods

    /// <summary>
    /// Gets the measurement value as a strongly-typed Measurement&lt;T&gt;
    /// </summary>
    public Measurement<T>? GetValue<T>() where T : Enum
    {
        if (Value is Measurement<T> measurement)
            return measurement;
        return null;
    }

    /// <summary>
    /// Sets the measurement value using a strongly-typed Measurement&lt;T&gt;
    /// </summary>
    public void SetValue<T>(Measurement<T> value) where T : Enum
    {
        Value = value;
    }

    /// <summary>
    /// Converts the current value to a different unit (with conversion)
    /// </summary>
    public void ChangeUnit<T>(T unit, int? accuracy = null) where T : Enum
    {
        var measurement = GetValue<T>();
        if (measurement == null) return;

        var converted = measurement.Value.To(unit);
        DecimalPoints = accuracy;
        Value = converted;
    }

    #endregion
}
